/*
 * This test verifies the fix for a bug where attaching to a process then
 * detaching could leave the process suspended, due to it getting the SIGSTOP
 * signal generated by the ptrace(PT_ATTACH...) delivered to it because the
 * waitpid after ptrace-attach failed to verify that it received the actual stop
 * signal.
 *
 * The test involves three processes. First, is the parent. This just monitors
 * the target. The parent should not see the target process suspend, as that
 * should all be hidden by any prospective "debugger"
 *
 * The next process is the target, as forked by the parent. It will start 10
 * threads, and, on setting a volatile variable, each thread will start sending
 * itself signals.
 *
 * Finally, the "debugger" - the first time the target handles the signal it is
 * sending to itself, it will fork, and start the debugger. The debugger will
 * attach to the target, then detach. It should stop, and then resume, the
 * target. If its working properly, it will consume any SIGSTOP signals
 */
#include <pthread.h>
#include <assert.h>
#include <sys/procfs.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <signal.h>
#include <vector>
#include <iostream>
#include <sys/types.h>
#include <sys/wait.h>
#include <err.h>
#include <libpstack/proc.h>
#include <stdarg.h>

volatile bool trapped;
char pidstr[32];

std::vector<pthread_t> threads; // all the threads in the process.

volatile enum {
    IDLE,
    TRAP,
    DONE
} state = IDLE;

void *
entry(void *)
{
    while (state != DONE) {
        if (state == TRAP) {
            tgkill(getpid(), gettid(), SIGTRAP);
        }
    }
    return 0;
}

void
usage() {
   std::cerr
      << "usage: threads [-w]\n"
      << "\t -w: wait to be killed, instead of raising SIGBUS.\n"
      ;
}

// waitpid + error handling.
int
waitforpid(const char *from, pid_t pid, int flags = 0) {
    int status, rv;
    do {
        rv = waitpid(pid, &status, flags);
    } while (rv == -1 && errno == EINTR);
    if (rv == -1) {
        err(1, "%s: unexpected error from waitpid", from);
    }
    assert(rv == pid);
    std::cerr << from << ": wait returns " << pstack::Procman::WaitStatus{status} << "\n";
    return status;
}

int
debugger() {
    // This is the debugger.
    try {
        std::cerr << "stopping process momentarily from child\n";
        pstack::Context pstack;
        auto proc = pstack::Procman::Process::load(pstack, nullptr, pidstr);
        pstack::Procman::StopProcess here{proc.get()};
    }
    catch (const std::exception &ex) {
        err(1, "failed to stop process %s", ex.what());
    }
    return 0;
}

void sigtrap([[maybe_unused]] int sig, [[maybe_unused]] siginfo_t *si, [[maybe_unused]] void *ctx) {
    if (trapped) {
        // after the first signal, we just return.
        return;
    }
    trapped = true;
    pid_t pid = fork();
    if (pid == 0) {
        _exit(debugger());

    }
    int status = waitforpid("target", pid);
    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
        err(1, "unexpected status code %d from waitpid", status);
    }
    std::cerr << "child done\n";
    state = DONE;
}

int
target()
{
   pthread_attr_t attrs;
   pthread_attr_init(&attrs);
   pthread_attr_setscope(&attrs, PTHREAD_SCOPE_SYSTEM);

   snprintf(pidstr, sizeof pidstr, "%d", (int)getpid());
   struct sigaction sa{};
   sa.sa_sigaction = sigtrap;
   sa.sa_flags |= SA_SIGINFO;
   sigaction(SIGTRAP, &sa, nullptr);

   // Create 10 threads.
   for (int i = 0; i < 10; i++) {
      pthread_t tid;
      int rc = pthread_create(&tid, &attrs, entry, reinterpret_cast<void *> ( i ) );
      assert(rc == 0);
      threads.push_back(tid);
   }
   sleep(2);
   state = TRAP;
   for (auto t : threads) {
        void *rv;
        pthread_join(t, &rv);
    }
    return 0;
}

void
testfail(pid_t pid, const char *reason, ...) {
    va_list args;
    va_start(args, reason);
    kill(pid, SIGKILL);
    waitforpid("waiting for failed process to complete", pid);
    verrx(1, reason, args);
}

int
main([[maybe_unused]] int argc, [[maybe_unused]] char *argv[])
{
    static pid_t pid = fork();
    if (pid == -1) {
        err(1, "failed to fork?");
    }
    if (pid == 0) {
        _exit(target());
    }

    signal(SIGALRM, []([[maybe_unused]] int sig) {
        testfail(pid, "timed out waiting for threads to exit");
    });
    alarm(60);
    int status = waitforpid("parent", pid, WUNTRACED);
    // This should not happen, but it will if we botch the ptrace/waitpid
    // handshake in the face of noisy signals.
    if (WIFSTOPPED(status)) {
        testfail(pid, "child got stopped by sig %d - I should not have seen that happen",
                 WSTOPSIG(status));
    }
    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
        testfail(pid, "unexpected status code %d from waitpid", status);
    }
}
